""" Wired.jl 
    Biot-Savart law integration for current-carrying rings
"""

"""
    biotsavart!(B::AbstractArray, nodes::AbstractArray, rings::CircularRings; 
                errmax=1e-16)

Calculate the magnetic flux density at nodes in 3D space generated by a series of 
circular current-carrying rings.

Modifies an existing array containing the magnetic flux density components in-place. 
Performs a current density correction for points within the specified minor radius 
of the loop. Zeroes out singularity points. 

Reference:
"Simple Analytic Expressions for the Magnetic Field of a Circular Current Loop"
Simpson, Lane, Immer, Youngquist (2001)
https://ntrs.nasa.gov/api/citations/20010038494/downloads/20010038494.pdf 
"""
@views function biotsavart!(B::AbstractArray{T}, nodes::AbstractArray{T}, rings::AbstractArray{CircularRing{T}}; 
                            errmax=1e-8, mu_r=1.0) where T<:Real

    T_ = T
    if !(T<:AbstractFloat)
        T_ = precision 
    end

    Nnodes = size(nodes)[1]
    B_ = zeros(T_, Nnodes,3)     # Define separately for reasons below
    r = zeros(T_, Nnodes)
    alpha = zeros(T_, Nnodes)
    a2 = zeros(T_, Nnodes)
    beta = zeros(T_, Nnodes)
    k2 = zeros(T_, Nnodes)
    E = zeros(T_, Nnodes)
    K = zeros(T_, Nnodes)
    Jdensity_correction = zeros(T_, Nnodes)

    # In-plane radius for each node 
    rho = sqrt.(nodes[:,1].^2 .+ nodes[:,2].^2)
 
    for ring in rings

        a = ring.R
        C = mu0 * ring.I / pi

        # Calculate intermediate variables 
        r .= sqrt.(nodes[:,1].^2 .+ nodes[:,2].^2 .+ (nodes[:,3] .- ring.H).^2)
        a2 .= a.^2 .+ r.^2 .- 2 .* a .* rho 
        alpha .= sqrt.(abs.(a2))
        beta .= sqrt.(a^2 .+ r.^2 .+ 2 .* a .*rho)
        k2 .= 1 .- a2./(beta.^2)

        # Solve elliptic integrals
        K .= ellipK.(k2; errmax=errmax)
        E .= ellipE.(k2; errmax=errmax)

        # Calculate magnetic flux density 
        B_[:,1] .= mu_r .* (C .* nodes[:,1] .* nodes[:,3] ./ (2 .* a2 .* beta .* rho.^2)) .* ((a^2 .+ r.^2) .* E .- a2.*K)  
        B_[:,2] .= mu_r .* B_[:,1] .* nodes[:,2] ./ nodes[:,1]       # Note singularity
        B_[:,3] .= mu_r .* (C ./ (2 .* a2 .* beta)) .* ((a.^2 .- r.^2) .* E .+ a2 .* K)

        # Zero out singularity points and correct when inside the minor radius
        # https://discourse.julialang.org/t/avoiding-allocations-in-a-map-over-a-tuple/105734/2
        map!(x -> isnan(x) ? 0.0 : x, B_, B_)
        map!(x -> x < ring.r ? (x^2)/ring.r^2 : 1.0, Jdensity_correction, alpha)
        B .+= B_ .*= Jdensity_correction

    end
end


"""
    biotsavart(nodes::AbstractArray, rings::AbstractArray{CircularRing}; 
                    mu_r=1.0, errmax=1e-16)

Calculate the magnetic flux density at nodes in 3D space caused by a series of 
circular current-carrying rings.

Allocates a new array for the magnetic flux density solution.
"""
function biotsavart(nodes::AbstractArray{T}, rings::AbstractArray{CircularRing{T}}; 
                    mu_r=1.0, errmax=1e-16) where T<:Real

    B = zeros(T, size(nodes))
    biotsavart!(B, nodes, rings; mu_r=mu_r, errmax=errmax)

    return B
end


"""
    biotsavart!(B::AbstractArray, nodes::AbstractArray, rect::RectangularRings; Nmin=2)

Calculate the magnetic flux density for a series of circular loops with rectangular
    cross-sections.

# Arguments 
- `B::AbstractArray`: Nx3 array of B-field components at each node 
- `nodes::AbstractArray`: Nx3 array of locations in 3D space at which to calculate fields 
- `rect::Vector{RectangularRing}`: B-field sources; have rectangular cross-section 
## Optional 
- `Nmin=2`: minimum number of loops to generate for the smallest loop side
- `errmax=1e-6`: calculation precision for the elliptic integrals

Modifies the B-field matrix in-place.
"""
function biotsavart!(B::AbstractArray{T}, nodes::AbstractArray{T}, rect::AbstractArray{RectangularRing{T}}; 
                        mu_r=1.0, Nmin=2, errmax=1e-8) where T<:Real

    # Convert to circular rings first 
    circ = makecircrings(rect, Nmin) 

    biotsavart!(B, nodes, circ; mu_r=mu_r, errmax=errmax)
    return circ
end


"""
    biotsavart(B::AbstractArray, nodes::AbstractArray, rect::RectangularRings; Nmin=2)

Calculate the magnetic flux density for a series of circular loops with rectangular
    cross-sections.

Allocates a new array for the B-field components.
"""
function biotsavart(nodes::AbstractArray{T}, rect::AbstractArray{RectangularRing{T}}; 
                        mu_r=1.0, Nmin=2, errmax=1e-8) where T<:Real
    
    B = zeros(T, size(nodes))
    biotsavart!(B, nodes, rect; mu_r=mu_r, Nmin=Nmin, errmax=errmax)

    return B 
end


"""
    bfield(nodes::AbstractArray, rings::Vector{Ring}; Nmin=2, errmax=1e-8, Nt=0)

Calculate the B-field at a collection of points in 3D space, generated by a series of
`Ring` objects.

# Arguments
- `nodes::AbstractArray`: Nx3 `Matrix` containing (x,y,z) coordinates of points in 3D space
- `wires::Vector{<:Ring}`: `Ring` objects contributing to the magnetic field (circular or rectangular cross-section)
- `Nmin::Integer`: minimum number of `CircularRing` objects to use to represent the shortest edge of a rectangular cross-section
- `errmax::Float64`: maximum error tolerance for elliptic integral calculations
- `Nt::Integer`: number of threads to use for the calculation (default: all available threads)

# Returns
Nx3 `Matrix` containing magnetic flux density vectors at each of the points in 3D space represented by `nodes`

"""
function bfield(nodes::AbstractArray{T}, rings::Vector{<:Ring}; 
                mu_r=1.0, Nmin=2, errmax=1e-8, Nt=0) where T<:Real

    P = findparam(rings)
    if P != T 
        nodes = convert.(P, nodes)
    end

    Ns = length(rings)
    if Nt == 0 
        # Default is to use all available threads
        Nt = Threads.nthreads()
    elseif Nt > Threads.nthreads()
        println("Error. Number of threads specified is greater than available threads.")
    end

    # Spawn a new task for each thread by splitting up the source array
    tasks = Vector{Task}(undef, Nt)
    for it = 1:Nt 
        if isa(rings, Vector{CircularRing{P}})
            @views tasks[it] = Threads.@spawn biotsavart(nodes, rings[threadindices(it, Nt, Ns)]; mu_r=mu_r, errmax=errmax)
        else 
            @views tasks[it] = Threads.@spawn biotsavart(nodes, rings[threadindices(it, Nt, Ns)]; mu_r=mu_r, errmax=errmax, Nmin=Nmin)
        end
    end
    
    # Get the result from each calculation and add it to the output array 
    B = zeros(P, size(nodes))
    for it = 1:Nt 
        B .+= fetch(tasks[it]) 
    end 

    return B
end