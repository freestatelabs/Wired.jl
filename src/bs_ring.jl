""" Biot-Savart law integration for rings
    (c) 2024 ryan@freestatelabs
"""


"""
    biotsavart!(B::AbstractArray, nodes::AbstractArray, rings::CircularRings; 
                errmax=1e-16)

Calculate the magnetic flux density at nodes in 3D space generated by a series of 
circular current-carrying rings.

Modifies an existing array containing the magnetic flux density components in-place. 
Performs a current density correction for points within the specified minor radius 
of the loop. Zeroes out singularity points. 

Reference:
"Simple Analytic Expressions for the Magnetic Field of a Circular Current Loop"
Simpson, Lane, Immer, Youngquist (2001)
https://ntrs.nasa.gov/api/citations/20010038494/downloads/20010038494.pdf 
"""
@views function biotsavart!(B::AbstractArray, nodes::AbstractArray, rings::AbstractArray{CircularRing}; 
                            errmax=1e-8, mu_r=1.0)

    Nnodes = size(nodes)[1]
    B_ = Matrix{Float64}(undef, Nnodes,3)     # Define separately for reasons below
    r = Vector{Float64}(undef, Nnodes)
    alpha = Vector{Float64}(undef, Nnodes)
    a2 = Vector{Float64}(undef, Nnodes)
    beta = Vector{Float64}(undef, Nnodes)
    k2 = Vector{Float64}(undef, Nnodes)
    E = Vector{Float64}(undef, Nnodes)
    K = Vector{Float64}(undef, Nnodes)
    Jdensity_correction = zeros(Nnodes)

    # In-plane radius for each node 
    rho = sqrt.(nodes[:,1].^2 .+ nodes[:,2].^2)
 
    for ring in rings

        a = ring.R
        C = mu0 * ring.I / pi

        # Calculate intermediate variables 
        r .= sqrt.(nodes[:,1].^2 .+ nodes[:,2].^2 .+ (nodes[:,3] .- ring.H).^2)
        a2 .= a.^2 .+ r.^2 .- 2 .* a .* rho 
        alpha .= sqrt.(abs.(a2))
        beta .= sqrt.(a^2 .+ r.^2 .+ 2 .* a .*rho)
        k2 .= 1 .- a2./(beta.^2)

        # Solve elliptic integrals
        K .= ellipK.(k2; errmax=errmax)
        E .= ellipE.(k2; errmax=errmax)

        # Calculate magnetic flux density 
        B_[:,1] .= mu_r .* (C .* nodes[:,1] .* nodes[:,3] ./ (2 .* a2 .* beta .* rho.^2)) .* ((a^2 .+ r.^2) .* E .- a2.*K)  
        B_[:,2] .= mu_r .* B_[:,1] .* nodes[:,2] ./ nodes[:,1]       # Note singularity
        B_[:,3] .= mu_r .* (C ./ (2 .* a2 .* beta)) .* ((a.^2 .- r.^2) .* E .+ a2 .* K)

        # Zero out singularity points and correct when inside the minor radius
        # https://discourse.julialang.org/t/avoiding-allocations-in-a-map-over-a-tuple/105734/2
        map!(x -> isnan(x) ? 0.0 : x, B_, B_)
        map!(x -> x < ring.r ? (x^2)/ring.r^2 : 1.0, Jdensity_correction, alpha)
        B .+= B_ .*= Jdensity_correction

    end
end


"""
    biotsavart(nodes::AbstractArray, rings::Vector{CircularRing}; errmax=1e-16)

Calculate the magnetic flux density at nodes in 3D space caused by a series of 
circular current-carrying rings.

Allocates a new array for the magnetic flux density solution.
"""
function biotsavart(nodes::AbstractArray, rings::AbstractArray{CircularRing}; errmax=1e-16)

    B = zeros(size(nodes))
    biotsavart!(B, nodes, rings; errmax=errmax)

    return B
end


"""
    biotsavart!(B::AbstractArray, nodes::AbstractArray, rect::RectangularRings; Nmin=2)

Calculate the magnetic flux density for a series of circular loops with rectangular
    cross-sections.

# Arguments 
- `B::AbstractArray`: Nx3 array of B-field components at each node 
- `nodes::AbstractArray`: Nx3 array of locations in 3D space at which to calculate fields 
- `rect::Vector{RectangularRing}`: B-field sources; have rectangular cross-section 
## Optional 
- `Nmin=2`: minimum number of loops to generate for the smallest loop side
- `errmax=1e-6`: calculation precision for the elliptic integrals

Modifies the B-field matrix in-place.
"""
function biotsavart!(B::AbstractArray, nodes::AbstractArray, rect::AbstractArray{RectangularRing}; 
                        Nmin=2, errmax=1e-8)

    # Convert to circular rings first 
    circ = makecircrings(rect, Nmin) 

    biotsavart!(B, nodes, circ; errmax=errmax)
    return circ
end


"""
    biotsavart!(B::AbstractArray, nodes::AbstractArray, rect::RectangularRings; Nmin=2)

Calculate the magnetic flux density for a series of circular loops with rectangular
    cross-sections.

Allocates a new array for the B-field components.
"""
function biotsavart(nodes::AbstractArray, rect::AbstractArray{RectangularRing}; 
                        Nmin=2, errmax=1e-8, Nt::Integer=0)
    
    B = zeros(size(nodes))
    biotsavart!(B, nodes, rect; Nmin=Nmin, errmax=errmax)

    return B 
end


"""
    bfield(nodes::AbstractArray, rings::Vector{<:Ring}; Nmin=2, errmax=1e-8, Nt=0)
"""
function bfield(nodes::AbstractArray, rings::Vector{<:Ring}; Nmin=2, errmax=1e-8, Nt=0)

    Ns = length(rings)
    if Nt == 0 
        # Default is to use all available threads
        Nt = Threads.nthreads()
    end

    # Spawn a new task for each thread by splitting up the source array
    tasks = Vector{Task}(undef, Nt)
    for it = 1:Nt 
        if isa(rings, Vector{CircularRing})
            @views tasks[it] = Threads.@spawn biotsavart(nodes, rings[threadindices(it, Nt, Ns)]; errmax=errmax)
        else 
            @views tasks[it] = Threads.@spawn biotsavart(nodes, rings[threadindices(it, Nt, Ns)]; errmax=errmax, Nmin=Nmin)
        end
    end
    
    # Get the result from each calculation and add it to the output array 
    B = zeros(size(nodes))
    for it = 1:Nt 
        B .+= fetch(tasks[it]) 
    end 

    return B
end