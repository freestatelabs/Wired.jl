var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for Wired.jl's public-facing API. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Wired ","category":"page"},{"location":"api/#Sources","page":"API","title":"Sources","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define custom source types.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Source\nWire\nRing\nCircularRing\nRectangularRing","category":"page"},{"location":"api/#Wired.Source","page":"API","title":"Wired.Source","text":"abstract type Source\n\nRepresents a time-invariant current source that generates a magnetic field\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.Wire","page":"API","title":"Wired.Wire","text":"struct Wire <: Source\n\nRepresents a finite wire segment in 3D space \n\nThe wire segment has a finite radius, such that numerical singularities are  prevented: the magnetic field generated by the wire segment has a finite (maximum) value on the surface at r=R, and decays linearly to zero at the center with r=0.\n\nFields\n\na0::Vector{Float64}: XYZ coordinates of the start of the wire vector\na1::Vector{Float64}: XYZ coordinates of the end of the wire vector \nI::Float64: total current in the filament\nR::Float64: radius of the wire segment\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.Ring","page":"API","title":"Wired.Ring","text":"abstract type Ring <: Source\n\nA circular current-carrying ring with circular or rectangular-cross-section.\n\nMajor axis of the ring is the Z-axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.CircularRing","page":"API","title":"Wired.CircularRing","text":"struct CircularRing <: Ring\n\nA circular current-carrying solid conducting ring with circular cross-section \n\nThe ring has a defined cross-section, such that numerical singularities are prevented  and the magnetic field can be accurately calculated within the ring itself.\n\nFields\n\nname::String: describes the filament\nH::Float64: distance along the Z-axis of the ring from the coordinate    system centroid to the ring centroid\nR::Float64: major radius of the ring\nr::Float64: minor radius of the ring (cross-section radius)\nI::Float64: current in the conducting ring; sign convention follows right-hand    rule about primary axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.RectangularRing","page":"API","title":"Wired.RectangularRing","text":"struct RectangularRing <: Ring\n\nA circular current-carrying solid conducting ring with rectangular cross-section \n\nThe ring has a defined cross-section, such that numerical singularities are prevented  and the magnetic field can be accurately calculated within the ring itself.\n\nFields\n\nname::String: describes the filament\nH::Float64: distance along the Z-axis of the ring from the coordinate    system centroid to the ring centroid\nR::Float64: major radius of the ring\nw::Float64: width of the ring cross-section \nh::Float64: height of the ring-cross-section\nI::Float64: current in the conducting ring; sign convention follows right-hand    rule about primary axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mathematical-Functions","page":"API","title":"Mathematical Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define high-performance version of elliptic integral and linear algebra functions optimized for use with this code.","category":"page"},{"location":"api/","page":"API","title":"API","text":"ellipK\nellipE\nellipKE\ncrossrows!\nnormrows!\nmultrows!\ndotrows!","category":"page"},{"location":"api/#Wired.ellipK","page":"API","title":"Wired.ellipK","text":"function ellipK(k2; itmax=100, errmax=1e-8)\n\nSolve the complete elliptic integral of the first kind\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.ellipE","page":"API","title":"Wired.ellipE","text":"function ellipE(k2; itmax=100, errmax=1e-8)\n\nSolve the complete elliptic integral of the second kind\n\nReference: https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.ellipKE","page":"API","title":"Wired.ellipKE","text":"ellipKE(k2; itmax=100, errmax=1e-12)\n\nSolve the complete elliptic integrals of the first and second kinds.\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.crossrows!","page":"API","title":"Wired.crossrows!","text":"crossrows!(C::AbstractArray, A::AbstractArray, b::Vector)\n\nCross each row of A by a 3-length vector b and place in C, i.e. \n\nC[i,:] = cross(A[i,:], b)\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.normrows!","page":"API","title":"Wired.normrows!","text":"normrows!(b::Vector, A::AbstractArray)\n\nCalculate the vector norm of each row in Nx3 matrix and place in b, i.e. \n\nb[i] = norm(A[i,:])\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.multrows!","page":"API","title":"Wired.multrows!","text":"multrows!(A::AbstractArray, b::Vector)\n\nIn-place element-wise multiplication of each row of an Nx3 matrix by the  corresponding element in vector b, i.e.\n\nA[i,:] .*= b[i]\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.dotrows!","page":"API","title":"Wired.dotrows!","text":"dotrows!(c::Vector, A::AbstractArray, b::Vector)\n\nIn-place dot-product of the rows of A by vector b; place in C, i.e. \n\nc[i] .*= dot(A[i,:], b)       # or C[i,:] .*= sum(A[i,:] .* b)\n\n\n\n\n\n","category":"function"},{"location":"api/#Processing-Routines","page":"API","title":"Processing Routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"makewires\nmakecircrings\nthreadindices","category":"page"},{"location":"api/#Wired.makewires","page":"API","title":"Wired.makewires","text":"makewires(mesh::Mesh)\n\nCreate finite Wire segment sources from a Mesh\n\nArguments\n\nmesh::Mesh: the finite element mesh to generate Wires from \nratio=2.0: the length/radius ratio for the wire segments. Set to 2.0 for perfect    cubes and 1.0 for tetrahedrons.\n\nReturns\n\nVector{Wire} containing all Wire objects in the mesh\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.makecircrings","page":"API","title":"Wired.makecircrings","text":"function makecircrings(rect::RectangularRings; Nmin=2)\n\nFilamentize Rings with rectangular cross-sections. \n\nFor a cross-section with side lengths L1 and L2, with L1 < L2, the spacing s  between filament centroids is given by s = L1 / Nmin. This spacing is used for  creating filaments along both sides, such that N1 = Nmin and N2 ~= L2 / s (with  integer rounding.)\n\nArguments\n\nrect::Vector{RectangularRing}: RectangularRing objects from which to create    CircularRing objects \n'Nmin=2`: Minimum number of CircularRings per side of the original cross-section. \n\nReturns\n\nVector{CircularRing}, which is of indeterminate length apriori.\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.threadindices","page":"API","title":"Wired.threadindices","text":"threadindices(it::Integer, Nt::Integer, N::Integer)\n\nSplit a problem up for multi-threaded operation\n\nFor thread number it, total number of threads Nt, and total number of  tasks N, determine the start/stop index for that particular thread number\n\n\n\n\n\n","category":"function"},{"location":"api/#File-I/O","page":"API","title":"File I/O","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions for loading and save data to/from files.","category":"page"},{"location":"api/","page":"API","title":"API","text":"loadmesh \nsavemesh\nloadrings\nsaverings\nloadwires\nsavewires","category":"page"},{"location":"api/#Wired.loadmesh","page":"API","title":"Wired.loadmesh","text":"loadmesh(fn::String)\n\nLoad a finite element mesh from a file\n\nThe first row is a header row. The subsequent rows are:  Xcentroid, Ycentroid, Zcentroid, volume, JdensityX, JdensityY, JdensityZ \n\nJdensity is optional (the file may be 4-width)\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.savemesh","page":"API","title":"Wired.savemesh","text":"savemesh(fn::String, mesh::Mesh)\n\nSave a finite element mesh to a file. \n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.loadrings","page":"API","title":"Wired.loadrings","text":"loadrings(fn::String)\n\nLoad Ring objects from file.\n\nReturns\n\nVector{CircularRing}, Vector{RectangularRing}\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.saverings","page":"API","title":"Wired.saverings","text":"saverings(fn::String, rings::Vector{<:Source})\n\nSave Ring objects to a file\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.loadwires","page":"API","title":"Wired.loadwires","text":"loadwires(fn::String)\n\nLoad Wire objects from a file\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.savewires","page":"API","title":"Wired.savewires","text":"savewires(fn::String, wires::Vector{Wire})\n\nSave Wire objects to a file \n\n\n\n\n\n","category":"function"},{"location":"api/#Output-Fields","page":"API","title":"Output Fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions that create basic sets of points at which to calculate fields.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Line\nMesh","category":"page"},{"location":"api/#Wired.Line","page":"API","title":"Wired.Line","text":"line(start, stop, N)\n\nRepresents points along a line in 3D space\n\nFields\n\nstart::Vector{Float64}: 3-length start point of the line \nstop::Vector{Float64}: 3-length end point of the line \nN::Integer: number of points along the line \nnodes::Matrix{Float64}: Nx3Matrix` of locations for calculations\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.Mesh","page":"API","title":"Wired.Mesh","text":"mutable struct Mesh\n\nDefine a finite element mesh, which can act as a Source and a Field\n\nFields\n\nnodes::AbstractArray: Nx3 matrix of positions in 3D space (element centroids)\nvolumes::AbstractArray: N-length vector of volume of each element \nJdensity::AbstractArray: Nx3 matrix of current density vectors at each element \nmu_r::Float64: Relative magnetic permeability of the mesh\n\n\n\n\n\n","category":"type"},{"location":"api/#Biot-Savart-Solvers","page":"API","title":"Biot-Savart Solvers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions that calculate the magnetic flux density due to defined  current sources. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"bfield","category":"page"},{"location":"api/#Wired.bfield","page":"API","title":"Wired.bfield","text":"bfield(nodes::AbstractArray, rings::Vector{Ring}; Nmin=2, errmax=1e-8, Nt=0)\n\nCalculate the B-field at a collection of points in 3D space, generated by a series of Ring objects.\n\nArguments\n\nnodes::AbstractArray: Nx3 Matrix containing (x,y,z) coordinates of points in 3D space\nwires::Vector{<:Ring}: Ring objects contributing to the magnetic field (circular or rectangular cross-section)\nNmin::Integer: minimum number of CircularRing objects to use to represent the shortest edge of a rectangular cross-section\nerrmax::Float64: maximum error tolerance for elliptic integral calculations\nNt::Integer: number of threads to use for the calculation (default: all available threads)\n\nReturns\n\nNx3 Matrix containing magnetic flux density vectors at each of the points in 3D space represented by nodes\n\n\n\n\n\nbfield(nodes::AbstractArray, wires::Vector{Wire}; \n        Nt::Integer=0, mu_r=1.0)\n\nCalculate the B-field at a collection of points in 3D space, generated by a series of finite-length Wire objects.\n\nArguments\n\nnodes::AbstractArray: Nx3 Matrix containing (x,y,z) coordinates of points in 3D space\nwires::Vector{Wire}: Wire objects contributing to the magnetic field \nNt::Integer: number of threads to use for the calculation (default: all available threads)\n\nReturns\n\nNx3 Matrix containing magnetic flux density vectors at each of the points in 3D space represented by nodes\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage","page":"Basic Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Basic usage guide for Wired.jl.","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"All dimensions are in MKS: length in meters, current in amperes, field in Tesla.","category":"page"},{"location":"usage/#Fields","page":"Basic Usage","title":"Fields","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"All results are calculated on Field objects. At the most basic, a Field is a Matrix representing points in 3D space, i.e.:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"julia> line = Line([0, 0, 0], [1, 0, 0], 11);\n\njulia> line.nodes\n11Ã—3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.1  0.0  0.0\n 0.2  0.0  0.0\n 0.3  0.0  0.0\n 0.4  0.0  0.0\n 0.5  0.0  0.0\n 0.6  0.0  0.0\n 0.7  0.0  0.0\n 0.8  0.0  0.0\n 0.9  0.0  0.0\n 1.0  0.0  0.0","category":"page"},{"location":"usage/#Sources","page":"Basic Usage","title":"Sources","text":"","category":"section"},{"location":"usage/#Wire-Source","page":"Basic Usage","title":"Wire Source","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"The most basic type of source is a Wire: a finite-length, circular conductor in 3D space. The Wire is completely defined by four parameters:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"The start location of the wire (3-length vector)\nThe end location of the wire (3-length vector)\nThe total current flowing in the wire\nThe radius of the wire","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"julia> start = [0, 0, 0];\njulia> stop = [3, 100, 0];\njulia> current = 10;\njulia> radius = 0.01;\njulia> wire = Wire(start, stop, current, radius)\nWire([0.0, 0.0, 0.0], [3.0, 100.0, 0.0], 10.0, 0.01)","category":"page"},{"location":"usage/#Ring-Sources","page":"Basic Usage","title":"Ring Sources","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Wired.jl supports two kinds of Ring sources: CircularRing's and RectangularRing's. The major axis is the Z-axis. Each is defined by the following parameters:","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"H: the height above the horizontal (XY) plane \nR: the major radius, i.e. the radius from the central (Z) axis to the center of the ring cross-section\nI: the total current in the conductor \nr: the minor radius (for a circular cross-section)\nw,h: the width and height (for a rectangular cross-section)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"julia> H=0;    R=1.0;    I=1000;    r=0.1;\n\njulia> ring = CircularRing(\"Circular Ring 1\", H, R, r, I)\nCircularRing(\"Circular Ring 1\", 0.0, 1.0, 0.1, 1000.0)","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"julia> H=1.0;    R=2.0;    I=2000;    w=0.05;    h=0.10;\n\njulia> ring = RectangularRing(\"Rectangular Ring 1\", H, R, w, h, I)\nRectangularRing(\"Rectangular Ring 1\", 1.0, 2.0, 0.05, 0.1, 2000.0)","category":"page"},{"location":"usage/#Finite-Element-Meshes","page":"Basic Usage","title":"Finite Element Meshes","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Wired.jl provides operations for working with finite element meshes. All outputs are calculated at the centroid of the elements. The current density within the element is used to approximate a finite-length current-carrying Wire with circular cross-section (see Finite Element Meshes)","category":"page"},{"location":"usage/#Load-a-mesh-from-a-file","page":"Basic Usage","title":"Load a mesh from a file","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Wired.jl assumes the file is comma-separated format, with the first three columns as x,y,z coordinates of the element centroid, the fourth column is the element volume, and the fifth through seventh columns are the elemental current density vectors.","category":"page"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"julia> mesh = loadmesh(\"testmesh.csv\")\n\njulia> wires = makewires(mesh)          # convert to Wire objects  \n\njulia> B = bfield(mesh.nodes, wires)\t# calculate self-field   ","category":"page"},{"location":"benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Code benchmarking for Wired.jl (speed tests).  ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"All benchmarks performed using a 2021 M1 MacBook Pro (6+2 physical cores, 16GB RAM).","category":"page"},{"location":"benchmarking/#Basic-Problem","page":"Benchmarking","title":"Basic Problem","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"The benchmark problem is simple: determine how fast the program can calculate the Biot Savart Law for different numbers of sources and of node (output) points. ","category":"page"},{"location":"benchmarking/#Wire-Sources","page":"Benchmarking","title":"Wire Sources","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Each Wire has an effect on each output point, and there are often many sources and many output locations in a problem, so this benchmark assumes equal numbers of sources and output points (N). For example, for N=1000, there are 1000 source Wire objects and 1000 output node locations, for a total of 1000 x 1000 = 1M computations.","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Computational time in milliseconds for different Wire problem sizes using various numbers of threads: ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"N Computations 1 Thread 2 Threads 4 Threads 6 Threads\n1000 1M 7.5 3.9 2.1 1.5\n2000 4M 29.4 15.0 7.7 5.4\n4000 16M 116.1 58.7 30.5 21.7\n8000 64M 494 248 125 89.2\n10000 100M 752 388 200 135","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"On this machine, the increase in computation time is roughly proportional to the problem size (N^2), and roughly proportional to the number of threads until Nt=4, when the benefit of using more threads for these problem sizes starts diminishing.  ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"In other words - the program can run 100 million calculations in 1/8 of a second on a several-generation old consumer laptop. ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"(Image: Wire Source Benchmarks)","category":"page"},{"location":"benchmarking/#Ring-Sources","page":"Benchmarking","title":"Ring Sources","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"When using the Ring object as a source, the scaling follows a similar trend. However, each Ring is about 6x more computational expensive than a Wire source. This is acceptable, as replacing a Ring with Wire objects would require many more than 6x Wire's. ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Computational time in milliseconds for different Ring problem sizes using various numbers of threads: ","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"N Computations 1 Thread 2 Threads 4 Threads 6 Threads\n1000 1M 41.5 21.8 10.7 7.6\n2000 4M 164.3 82.6 42.9 28.6\n4000 16M 634.9 331.9 171.5 116.1\n8000 64M 2566.3 1275.2 676.4 457.8\n10000 100M 4062.6 1978.1 1057.8 714.1","category":"page"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"(Image: Ring Source Benchmarks)","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory manual for Wired.jl","category":"page"},{"location":"theory/#Basics","page":"Theory","title":"Basics","text":"","category":"section"},{"location":"theory/#Unit-System","page":"Theory","title":"Unit System","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"All units are MKS:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Length in meters\nElectric current in amperes\nMagnetic flux density in Tesla","category":"page"},{"location":"theory/#Coordinate-System","page":"Theory","title":"Coordinate System","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Wired.jl uses a global Cartesian coordinate system. It does not currently support  coordinate system conversions, or cylindrical, spherical, or toroidal systems. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For current-carrying Ring objects, the primary axis of the ring is the Z axis.","category":"page"},{"location":"theory/#The-Biot-Savart-Law","page":"Theory","title":"The Biot-Savart Law","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Biot-Savart Law is a fundamental equation of magnetostatics, and analytically  determines the magnetic field generated by a constant electric current traveling  along a path in 3D space. Because it is analytical, it can  be very useful in accurately calculating the effects of complicated arrangements of currents in 3D space, by breaking down the larger problem into smaller pieces. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Wikipedia has a much better  description than provided here, but the core equation is a line integral:  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":" overrightarrowB(r) = fracmu_04pi int_CfracI dl times r r^3","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r is the location in 3D space at which the field is being computed \nmu_0 is the magnetic permeability of vacuum - free space (magnetic fields within materials may vary considerably)\nI is the current flowing along the path \ndl is a differential vector along the path \nl is a point on the path, such that r = r - l","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For input units in amps [A] and meters [m], the constant mu_0=4pi times 10^-7 [H/m] and overrightarrowB is in Tesla [T]. ","category":"page"},{"location":"theory/#Magnetic-Field-Around-a-Current-Carrying-Wire","page":"Theory","title":"Magnetic Field Around a Current-Carrying Wire","text":"","category":"section"},{"location":"theory/#Infinitely-Thin-Wire","page":"Theory","title":"Infinitely Thin Wire","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the case of an infinitely thin wire, this equation simplies greatly into the  common scalar form:  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"B(r) = fracmu_0 I2 pi r ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This equation computes the magnitude of the magnetic field, which is oriented tangent to a circle around the wire axis and perpendicular to the current path. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that the equation has a singularity at radius r=0 and predicts infinite  magnetic field at the center of the wire. Real conductors have finite cross-section and do not generate infinite magnetic fields. Also note that the magnetic field decays very quickly as the observation point moves further away from the current.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For more discussion see the Hyperphysics Textbook. ","category":"page"},{"location":"theory/#Circular-Solid-Conductor","page":"Theory","title":"Circular Solid Conductor","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Inside a solid conductor, the magnetic field is bounded, and is in fact zero on the axis. It is also now a function of the  magnetic permeability, `\\mu\\`, of the material that the current is travelling through. For some materials, like copper, this  value is close to that of free space, but for others, it can vary significantly.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"B(r) = fracmu I r2 pi R^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Outside the conductor, the calculation of the field is exactly the same.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice the difference between the graph and the previous: the maximum value of  the field is on the surface of the conductor and has a finite value. Also, the  field decays incredibly quickly: just 50mm (2\") away from the center of the  conductor, the field has decayed to less than 1/8 of its maximum value.","category":"page"},{"location":"theory/#Finite-Length-Wires","page":"Theory","title":"Finite Length Wires","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For simple, straight wires in 2D space, the Biot-Savart law is quite straightforward  and has limited applicability. However, it can be even more useful in determining  the magnetic fields generated by complex arrangements of current-carrying wires  by splitting the problem up into many small wires.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The purpose of Wired.jl is to integrate the Biot-Savart law over a large  number of outpoint points called nodes. In this case, the current sources are  discrete wires of a finite length, and an analytical solution is employed. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: Diagram)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If P is an arbitrary point in 3D space, and veca is a wire segment  carrying current I, then let vecb and vecc be vectors from P to the  start and end points of veca.  Assuming P is in free space, then the magnetic flux density at P is given by: ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"overrightarrowB = fracI cdot mu_04 pi cdot left( fracoverrightarrowa cdot overrightarrowcoverrightarrowc - fracoverrightarrowa cdot overrightarrowboverrightarrowb right) cdot fracoverrightarrowctimesoverrightarrowa overrightarrowc timesoverrightarrowa^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If there are many current sources and many output locations at which to observe the magnetic field, then this equation can be numerically integrated for all of them. This vector analytical solution corresponds to the infinitely thin wire scalar solution. ","category":"page"},{"location":"theory/#Current-Density-Correction","page":"Theory","title":"Current Density Correction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For node points within the radius of the solid conductor, this equation is multiplied by the following ratio:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"J_correction = fracr_o^2r^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where r_o = fracvecc times vecaa is the shortest distance from the node to the centerline of the Wire, and r is the finite radius of the Wire cross-section.","category":"page"},{"location":"theory/#Current-Carrying-Circular-Ring","page":"Theory","title":"Current-Carrying Circular Ring","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Reference: Simple Analytic Expressions for the Magnetic Field of a Current-Carrying Loop","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Similarly, the magnetic field generated by a current traveling in a loop can be expressed analytically. This is especially useful for solenoids such as those in electric motors. The equations are more involved. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given a current-carrying ring with finite circular cross-section and the following parameters:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Height above the XY plane H\nMajor radius R \nMinor radius a (cross-section radius)\nElectric current I ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the magnetic flux density at location (xyz) can be calculated.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Intermediate variables:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho^2 = x^2 + y^2\nr^2 = x^2 + y^2 + z^2\nalpha^2 = R^2 + r^2 - 2 space R space rho\nbeta^2 = R^2 + r^2 + 2 space R space rho\nk^2 = 1 - alpha^2  beta^2\nC = mu_0 space I  pi ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Elliptic integrals:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Complete elliptic integral of the first kind K(k) \nComplete elliptic integral of the second kind E(k) ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The magnetic flux density components:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\nvecB_x(xyz) = fracC space x space z2alpha^2 space beta space rho^2 left left( alpha^2 + r^2 right) space E(k^2) - alpha^2 K(k^2) right \nvecB_y(xyz) = fracyx space B_x \nvecB_z(xyz) = fracC2alpha^2 space beta left left( alpha^2 - r^2 right) space E(k^2) + alpha^2 K(k^2) right\nendaligned","category":"page"},{"location":"theory/#Current-Density-Correction-2","page":"Theory","title":"Current Density Correction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"A similar current density correction is applied to (xyz) locations that fall within the minor radius of the ring:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"J_correction = fracalpha^2a^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, note that in this case, the result is an approximation. See Validation for more details. ","category":"page"},{"location":"theory/#Finite-Element-Meshes","page":"Theory","title":"Finite Element Meshes","text":"","category":"section"},{"location":"theory/#Converting-Mesh-to-Wire-Objects","page":"Theory","title":"Converting Mesh to Wire Objects","text":"","category":"section"},{"location":"theory/#Other-Routines","page":"Theory","title":"Other Routines","text":"","category":"section"},{"location":"theory/#Treatment-of-Numerical-Singularities","page":"Theory","title":"Treatment of Numerical Singularities","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For certain situations (such as the vecB_x and vecB_y components of the magnetic field at the center of a ring), the analytical solution has a numerical singularity: it diverges to infty.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Wired.jl converts all singularities to the value of 0.0.","category":"page"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Code validation for Wired.jl.","category":"page"},{"location":"validation/#Infinite-Wire-with-Finite-Radius","page":"Validation","title":"Infinite Wire with Finite Radius","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Given an infinite wire along the z-axis with the following parameters:","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"r = 10 mm (radius of cross-section)\nI = 1 kA ","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Calculate the y-component of the magnetic field along the x-axis.  The analytical solution is provided by:  ","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"B_y(x) = fracmu space I2pispace r^2cdot x space (x leq r)","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"B_y(x) = fracmu space I2pi cdot x space (x  r)","category":"page"},{"location":"validation/#Code","page":"Validation","title":"Code","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"mu = 1.0; I = 1000; r = 1.0;\nwire = Wire([0, 0, -1e4], [0, 0, 1e4], I, r)\nline = Line([0,0,0], [2, 0, 0], 100)\n\nBy = bfield(line.nodes, [wire])[:,2]\nBanalytical = map(x -> (x > r) ? mu0*I/(2pi*x) : mu0*I*x/(2pi*r^2), line.nodes[:,1])\n\nusing Plots \np = plot()\nplot!(p, line.nodes[:,1], Banalytical, label=\"Analytical\")\nplot!(p, line.nodes[1:5:end,1], By[1:5:end], label=\"Wire\", linealpha=0, markershape=:circle)\nxlabel!(p, \"Distance Along X-Axis [m]\")\nylabel!(p, \"Magnetic Flux Density (By) [T]\")","category":"page"},{"location":"validation/#Result","page":"Validation","title":"Result","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Validation: Infinite Wire, Finite Radius)","category":"page"},{"location":"validation/#Circular-Ring-with-Finite-Radius","page":"Validation","title":"Circular Ring with Finite Radius","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Given a circular curent-carrying ring with a circular cross-section and the following parameters:","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"H = 00 m\nR = 20 m\nr = 01 m \nI = 10 kA","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Calculate the magnetic field at the following locations:","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Along the Z-axis from (0,0,0) to (0,0,1) [m]\nAlong the X-axis from (0,0,0) to (0,0,4) [m]","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"With the following methods","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Analytical (valid only for Z-axis)\nUsing a Wired.CircularRing primitive \nUsing a finite element mesh","category":"page"},{"location":"validation/#Code-2","page":"Validation","title":"Code","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"H = 0.0 \t# height above xy plane\nR = 2.0 \t# major radius\nI = 10e3 \t# 10kA current\nr = 0.1 \t# minor radius (cross-section)\n\nxaxis = Line([0,0,0], [4.0,0,0], 1000)\nzaxis = Line([0,0,0], [0,0,1.0], 1000)  \n\nanalytical(z) = mu0 * I * (R^2) ./ (2 .* (R^2 .+ z.^2).^1.5)\nring = CircularRing(\"Ring\", H, R, r, I) \n\nBz_ring = bfield(zaxis.nodes, [ring])\nBz_analytical = analytical.(zaxis.nodes[:,3])","category":"page"},{"location":"validation/#Result-2","page":"Validation","title":"Result","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"(Image: Z-Axis Results)","category":"page"},{"location":"#Wired.jl","page":"Home","title":"Wired.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, efficient Biot-Savart law integrator in Julia.","category":"page"},{"location":"#Project-Goals","page":"Home","title":"Project Goals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Develop the fastest, most efficient Biot-Savart Law integration code available\nProvide easy-to-use utilities for the end-user\nThoroughly document the code with clear and concise descriptions of how to implement it","category":"page"}]
}
