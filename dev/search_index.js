var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for Wired.jl's public-facing API. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Wired ","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define custom types.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Mesh\nWire\nCircularRing\nRectangularRing","category":"page"},{"location":"api/#Wired.Mesh","page":"API","title":"Wired.Mesh","text":"mutable struct Mesh\n\nDefine a finite element mesh, which can act as a Source and a Field\n\nFields\n\nnodes::AbstractArray: Nx3 matrix of positions in 3D space (element centroids)\nvolumes::AbstractArray: N-length vector of volume of each element \nJdensity::AbstractArray: Nx3 matrix of current density vectors at each element \nmu_r::Float64: Relative magnetic permeability of the mesh\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.Wire","page":"API","title":"Wired.Wire","text":"struct Wire <: Source\n\nRepresents a finite wire segment in 3D space \n\nThe wire segment has a finite radius, such that numerical singularities are  prevented: the magnetic field generated by the wire segment has a finite (maximum) value on the surface at r=R, and decays linearly to zero at the center with r=0.\n\nFields\n\na0::Vector{Float64}: XYZ coordinates of the start of the wire vector\na1::Vector{Float64}: XYZ coordinates of the end of the wire vector \nI::Float64: total current in the filament\nR::Float64: radius of the wire segment\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.CircularRing","page":"API","title":"Wired.CircularRing","text":"struct CircularRing <: Ring\n\nA circular current-carrying solid conducting ring with circular cross-section \n\nThe ring has a defined cross-section, such that numerical singularities are prevented  and the magnetic field can be accurately calculated within the ring itself.\n\nFields\n\nname::String: describes the filament\nH::Float64: distance along the Z-axis of the ring from the coordinate    system centroid to the ring centroid\nR::Float64: major radius of the ring\nr::Float64: minor radius of the ring (cross-section radius)\nI::Float64: current in the conducting ring; sign convention follows right-hand    rule about primary axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Wired.RectangularRing","page":"API","title":"Wired.RectangularRing","text":"struct RectangularRing <: Ring\n\nA circular current-carrying solid conducting ring with rectangular cross-section \n\nThe ring has a defined cross-section, such that numerical singularities are prevented  and the magnetic field can be accurately calculated within the ring itself.\n\nFields\n\nname::String: describes the filament\nH::Float64: distance along the Z-axis of the ring from the coordinate    system centroid to the ring centroid\nR::Float64: major radius of the ring\nw::Float64: width of the ring cross-section \nh::Float64: height of the ring-cross-section\nI::Float64: current in the conducting ring; sign convention follows right-hand    rule about primary axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mathematical-Functions","page":"API","title":"Mathematical Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define high-performance version of elliptic integral functions optimized for use with this code.","category":"page"},{"location":"api/","page":"API","title":"API","text":"ellipK\nellipE\nellipKE","category":"page"},{"location":"api/#Wired.ellipK","page":"API","title":"Wired.ellipK","text":"function ellipK(k2; itmax=100, errmax=1e-6)\n\nSolve the complete elliptic integral of the first kind\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.ellipE","page":"API","title":"Wired.ellipE","text":"function ellipE(k2; itmax=100, errmax=1e-6)\n\nSolve the complete elliptic integral of the second kind\n\nReference: https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.ellipKE","page":"API","title":"Wired.ellipKE","text":"ellipKE(k2; itmax=100, errmax=1e-12)\n\nSolve the complete elliptic integrals of the first and second kinds.\n\n\n\n\n\n","category":"function"},{"location":"api/#Processing-Routines","page":"API","title":"Processing Routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"makewires\nmakecircrings","category":"page"},{"location":"api/#Wired.makewires","page":"API","title":"Wired.makewires","text":"makewires(mesh::Mesh)\n\nCreate finite Wire segment sources from a Mesh\n\nArguments\n\nmesh::Mesh: the finite element mesh to generate Wires from \nratio=2.0: the length/radius ratio for the wire segments. Set to 2.0 for perfect    cubes and 1.0 for tetrahedrons.\n\nReturns\n\nVector{Wire} containing all Wire objects in the mesh\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.makecircrings","page":"API","title":"Wired.makecircrings","text":"function makecircrings(rect::RectangularRings; Nmin=2)\n\nFilamentize Rings with rectangular cross-sections. \n\nFor a cross-section with side lengths L1 and L2, with L1 < L2, the spacing s  between filament centroids is given by s = L1 / Nmin. This spacing is used for  creating filaments along both sides, such that N1 = Nmin and N2 ~= L2 / s (with  integer rounding.)\n\nArguments\n\nrect::Vector{RectangularRing}: RectangularRing objects from which to create    CircularRing objects \n'Nmin=2`: Minimum number of CircularRings per side of the original cross-section. \n\nReturns\n\nVector{CircularRing}, which is of indeterminate length apriori.\n\n\n\n\n\n","category":"function"},{"location":"api/#File-I/O","page":"API","title":"File I/O","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions for loading and save data to/from files.","category":"page"},{"location":"api/","page":"API","title":"API","text":"loadmesh \nloadrings","category":"page"},{"location":"api/#Wired.loadmesh","page":"API","title":"Wired.loadmesh","text":"loadmesh(fn::String)\n\nLoad a finite element mesh from a file\n\nThe first row is a header row. The subsequent rows are:  Xcentroid, Ycentroid, Zcentroid, volume, JdensityX, JdensityY, JdensityZ \n\nJdensity is optional (the file may be 4-width)\n\n\n\n\n\n","category":"function"},{"location":"api/#Wired.loadrings","page":"API","title":"Wired.loadrings","text":"loadrings(fn::String)\n\nLoad Ring objects from file.\n\nReturns\n\nVector{CircularRing}, Vector{RectangularRing}\n\n\n\n\n\n","category":"function"},{"location":"api/#Output-Fields","page":"API","title":"Output Fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions that create basic sets of points at which to calculate fields.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Line","category":"page"},{"location":"api/#Wired.Line","page":"API","title":"Wired.Line","text":"line(start, stop, N)\n\nCreate points along a line in 3D space. \n\n\n\n\n\n","category":"type"},{"location":"api/#Biot-Savart-Solvers","page":"API","title":"Biot-Savart Solvers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Define functions that calculate the magnetic flux density due to defined  current sources. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"biotsavart!","category":"page"},{"location":"api/#Wired.biotsavart!","page":"API","title":"Wired.biotsavart!","text":"biotsavart!(B::AbstractArray, nodes::AbstractArray, rings::CircularRings; \n            errmax=1e-16)\n\nCalculate the magnetic flux density at nodes in 3D space generated by a series of  circular current-carrying rings.\n\nModifies an existing array containing the magnetic flux density components in-place.  Performs a current density correction for points within the specified minor radius  of the loop. Zeroes out singularity points. \n\nReference: \"Simple Analytic Expressions for the Magnetic Field of a Circular Current Loop\" Simpson, Lane, Immer, Youngquist (2001) https://ntrs.nasa.gov/api/citations/20010038494/downloads/20010038494.pdf \n\n\n\n\n\nbiotsavart!(B::AbstractArray, nodes::AbstractArray, rect::RectangularRings; Nmin=2)\n\nCalculate the magnetic flux density for a series of circular loops with rectangular     cross-sections.\n\nArguments\n\nB::AbstractArray: Nx3 array of B-field components at each node \nnodes::AbstractArray: Nx3 array of locations in 3D space at which to calculate fields \nrect::Vector{RectangularRing}: B-field sources; have rectangular cross-section \n\nOptional\n\nNmin=2: minimum number of loops to generate for the smallest loop side\nerrmax=1e-6: calculation precision for the elliptic integrals\n\nModifies the B-field matrix in-place.\n\n\n\n\n\nbiotsavart!(nodes::AbstractArray{Float64}, wires::Vector{Wire})\n\nCalculate the magnetic flux density generated by a series of current-carrying  wire segments. \n\nModifies an existing output array for the B-field in-place. Performs a current  density correction for node points within the radius of the wire segment. Zeroes  out singularity points.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage","page":"Basic Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Basic Usage","title":"Basic Usage","text":"Basic usage guide for Wired.jl.","category":"page"},{"location":"benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Code benchmarking for Wired.jl","category":"page"},{"location":"benchmarking/#Basic-Problem","page":"Benchmarking","title":"Basic Problem","text":"","category":"section"},{"location":"benchmarking/#Parallel-Processing","page":"Benchmarking","title":"Parallel Processing","text":"","category":"section"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory manual for Wired.jl","category":"page"},{"location":"theory/#Biot-Savart-Law","page":"Theory","title":"Biot-Savart Law","text":"","category":"section"},{"location":"theory/#Sources","page":"Theory","title":"Sources","text":"","category":"section"},{"location":"theory/#Ring","page":"Theory","title":"Ring","text":"","category":"section"},{"location":"theory/#Wire-Segment","page":"Theory","title":"Wire Segment","text":"","category":"section"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Code validation for Wired.jl.","category":"page"},{"location":"#Wired.jl","page":"Home","title":"Wired.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, efficient Biot-Savart law integrator in Julia.","category":"page"}]
}
